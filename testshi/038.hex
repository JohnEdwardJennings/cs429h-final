@0

//tests jumping scenarios (including jumping backwards and forwards within loops) to test branch prediction
//includes a few control and data hazards to verify correctness

//setting up the loop
81e5 //movl r5, #30   
8316 //movl r6, #49
8ff7 //movl r7, #255 (for incrementing r5 by 1) 
8649 //movl r9, #100

//this first part tests backward looping (branching to a smaller address or a previous instruction)
//setting loop address
808c //movl r12, #8 (@8)

//incrementing r5 by 1 until it reads 49 (ascii for "1")
0575 //sub r5, r5, r7    
065a //sub r10, r6, r5
ea1c //jnz r12, r10 (jumps to address 8 while r5 does not read "1")

//storing r5 (now contains "1") and then immediately loading it into r0 to print
//also includes RAW hazard as we load from where we just stored
f915 //st r5, r9
f900 //ld r0, r9 

//now let's check forward branches (branching ahead in the program)

//setting up the looping addresses
824c //movl r12, #36
818e //movl r14, #24

//this will loop forward and then backward continuously about 50 times before exiting

//r5 is incremented by 1 until it contains the value 100
0575 //sub r5, r5, r7
095a //sub r10, r9, r5

//while r5 is less than 100, we jump forward to address 36
ea1c // (@24) jnz r12, r10

//we should only execute the next 3 instructions (printing "1") on the last iteration when branch is not taken
//tests a control hazard
8310 //movl r0, #49    
8310    
8310    

ea1e    // (@36) This immediately jumps back to address 24 if r5 is less than 100

ffff